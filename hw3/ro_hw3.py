# -*- coding: utf-8 -*-
"""Ro_hw3.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1-t8EnNeC5Ce1cthI9l_E4rDY5Z6Oc9V6
"""

import numpy as np 
import sympy as sp
import pprint
import matplotlib.pyplot as plt
from numpy.linalg import multi_dot

q1, q2, q3, q4, q5, q6, l1, l2, l3, l4, l5, l6, l7 = sp.symbols('q1 q2 q3 q4 q5 q6 l1 l2 l3 l4 l5 l6 l7')
def T_z(l):
     return np.array([ [1, 0, 0, 0],
                       [0, 1, 0, 0],
                       [0, 0, 1, l],
                       [0, 0, 0, 1]
                      ])
def T_x(l):
  return np.array([ [1, 0, 0, l],
                    [0, 1, 0, 0],
                    [0, 0, 1, 0],
                    [0, 0, 0, 1]
                  ])

def R_x(q):
  return np.array([[1,     0,           0,   0],
                  [0, sp.cos(q), -sp.sin(q), 0],
                  [0, sp.sin(q), sp.cos(q),  0],
                  [0,      0,           0,   1]
                   ])


def R_y(q):                
  return np.array([[sp.cos(q),  0,      sp.sin(q), 0],
                  [0,           1,          0,     0],
                  [-sp.sin(q),  0,      sp.cos(q), 0],
                  [0,           0,          0,     1]
                  ])
def R_z(q):            
  return np.array([[sp.cos(q),    -sp.sin(q),    0,  0],
                  [ sp.sin(q),     sp.cos(q),    0,  0],
                  [0,                     0,     1,  0],
                  [0,                     0,     0,  1]
                  ])

                    
# Skew theory
T = multi_dot([T_z(l1), R_z(q1), T_z(l2), T_x(l3),R_y(q2),T_z(l4) ,R_y(q3),T_z(l5),T_x(l6),R_x(q4),R_y(q5),T_x(l7), R_x(q6)])

A0 = np.eye(4)
A1 = multi_dot([T_z(l1), R_z(q1), T_z(l2),T_x(l3)])
A2 = multi_dot([A1,R_y(q2),T_z(l4)])
A3 = multi_dot([A2,R_y(q3),T_z(l5),T_x(l6)])
A4 = multi_dot([A3,R_x(q4)]) 
A5 = multi_dot([A4,R_y(q5),T_x(l7)]) 
A6 = multi_dot([A5, R_x(q6)]) 


O_6 = A6[:3,3] 
O_0 = A0[:3,3]
O_1 = A1[:3,3]
O_2 = A2[:3,3]
O_3 = A3[:3,3]
O_4 = A4[:3,3]
O_5 = A5[:3,3]

z0 = A0[:3, 2]
z1 = A1[:3, 2]
z2 = A2[:3, 2]
z3 = A3[:3, 2]
z4 = A4[:3, 2]
z5 = A5[:3, 2]

J1 = np.hstack(( np.cross(z0, (O_6 - O_0)),z0))
J2 = np.hstack(( np.cross(z1, (O_6 - O_1)),z1))
J3 = np.hstack(( np.cross(z2, (O_6 - O_2)),z2))
J4 = np.hstack(( np.cross(z3, (O_6 - O_3)),z3))
J5 = np.hstack(( np.cross(z4, (O_6 - O_4)),z4))
J6 = np.hstack(( np.cross(z5, (O_6 - O_5)),z5))
J = np.vstack((J1,J2,J3,J4,J5,J6))
J = sp.Matrix(J_)
J = J.subs([(l1, 346), (l2, 324), (l3, 321), (l4, 1075), (l5, 225), (l6, 1280), (l7, 215), (q1, np.pi/6), (q2, np.pi/6), (q3, np.pi/6), (q4, np.pi/6), (q5,np.pi/6 ),(q6,np.pi/6 )])





#Numerical derivatives 

# matrix derivatives
# translation
def HT_z(l):
  HT_z = sp.diff(sp.Matrix(T_z(l)), l)
  return np.array(HT_z)
def HT_x(l):
  HT_x = sp.diff(sp.Matrix(T_x(l)), l)
  return np.array(HT_x)
# rotation
def HR_x(q):
  HR_x = sp.diff(sp.Matrix(R_x(q)), q)
  return np.array(HR_x)
def HR_y(q):
  HR_y = sp.diff(sp.Matrix(R_y(q)), q)
  return np.array(HR_y)
def HR_z(q):
  HR_z = sp.diff(sp.Matrix(R_z(q)), q)
  return np.array(HR_z)
# zero value matrix derivatives only for rotations since translation will reamain the same
def H0_x(q):
  H0_x = sp.diff(sp.Matrix(R_x(q)), q).subs(q,0)
  return np.array(H0_x)
def H0_y(q):
  H0_y = sp.diff(sp.Matrix(R_y(q)), q).subs(q,0)
  return np.array(H0_y)
def H0_z(q):
  H0_z = sp.diff(sp.Matrix(R_z(q)), q).subs(q,0)
  return np.array(H0_z)

T0 = sp.Matrix(T[:3,:3]).inv()
T1 = T0.tolist()
for i in range(3):
  T1[i].append(0)
T1.insert(3, np.array([0,0,0,1]) )
T1 = np.array(T1)

Td1 = multi_dot([T_z(l1), HR_z(q1), T_z(l2), T_x(l3),R_y(q2),T_z(l4) ,R_y(q3),T_z(l5),T_x(l6),R_x(q4),R_y(q5),T_x(l7), R_x(q6),T1])
J_1 = np.hstack((Td1[0,3],Td1[1,3],Td1[2,3],Td1[2,1],Td1[0,2],Td1[1,0]))

Td2 = multi_dot([T_z(l1), R_z(q1), T_z(l2), T_x(l3),HR_y(q2),T_z(l4) ,R_y(q3),T_z(l5),T_x(l6),R_x(q4),R_y(q5),T_x(l7), R_x(q6),T1])
J_2 = np.hstack((Td2[0,3],Td2[1,3],Td2[2,3],Td2[2,1],Td2[0,2],Td2[1,0]))

Td3 = multi_dot([T_z(l1), R_z(q1), T_z(l2), T_x(l3),R_y(q2),T_z(l4) ,HR_y(q3),T_z(l5),T_x(l6),R_x(q4),R_y(q5),T_x(l7), R_x(q6),T1])
J_3 = np.hstack((Td3[0,3],Td3[1,3],Td3[2,3],Td3[2,1],Td3[0,2],Td3[1,0]))

Td4 = multi_dot([T_z(l1), R_z(q1), T_z(l2), T_x(l3),R_y(q2),T_z(l4) ,R_y(q3),T_z(l5),T_x(l6),HR_x(q4),R_y(q5),T_x(l7), R_x(q6),T1])
J_4 = np.hstack((Td4[0,3],Td4[1,3],Td4[2,3],Td4[2,1],Td4[0,2],Td4[1,0]))

Td5 = multi_dot([T_z(l1), R_z(q1), T_z(l2), T_x(l3),R_y(q2),T_z(l4) ,R_y(q3),T_z(l5),T_x(l6),R_x(q4),HR_y(q5),T_x(l7), R_x(q6),T1])
J_5 = np.hstack((Td5[0,3],Td5[1,3],Td5[2,3],Td5[2,1],Td5[0,2],Td5[1,0]))

Td6 = multi_dot([T_z(l1), R_z(q1), T_z(l2), T_x(l3),R_y(q2),T_z(l4) ,R_y(q3),T_z(l5),T_x(l6),R_x(q4),R_y(q5),T_x(l7), HR_x(q6),T1])
J_6 = np.hstack((Td6[0,3],Td6[1,3],Td6[2,3],Td6[2,1],Td6[0,2],Td6[1,0]))

J_ = np.vstack((J_1,J_2,J_3,J_4,J_5,J_6))
J_ = sp.Matrix(J_)
J_ = J_.subs([(l1, 346), (l2, 324), (l3, 321), (l4, 1075), (l5, 225), (l6, 1280), (l7, 215), (q1, np.pi/6), (q2, np.pi/6), (q3, np.pi/6), (q4, np.pi/6), (q5,np.pi/6 ),(q6,np.pi/6 )])
# let's check 
print(np.array(J-J_))

X = np.vstack((J1,J2,J3,J4,J5,J6))
J11 = X[:3,:3]
J11 = sp.Matrix(J11)
print(np.shape(J11))
print("det:",sp.simplify(J11.det()))

print(sp.simplify(J11.det()))

from mpmath import mp
Z = mp.matrix(J)
U, D, Vt = mp.svd_r(Z, compute_uv = True)
print("U =", U )
print("D =", D )
print("V(transpose) =", Vt )

mat = np.array([[5,2,1,0,0,4],
                [8,4,6,9,6,1],
                [4,2,0,1,2,7],
                [6,6,8,5,2,0],
                [0,2,3,5,9,6],
                [3,7,8,9,5,2]])
print(mat[:3,:3])